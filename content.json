{"meta":{"title":"lengmuyun's Blog","subtitle":null,"description":null,"author":"lengmuyun","url":"https://lengmuyun.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-04-15T12:37:38.067Z","updated":"2019-04-15T12:37:38.067Z","comments":true,"path":"404.html","permalink":"https://lengmuyun.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2019-05-04T06:39:56.339Z","updated":"2019-05-04T06:39:56.339Z","comments":true,"path":"categories/index.html","permalink":"https://lengmuyun.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-04-15T12:36:48.157Z","updated":"2019-04-15T12:36:48.157Z","comments":true,"path":"tags/index.html","permalink":"https://lengmuyun.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ThreadLocal应用及源码解析","slug":"ThreadLocal应用及源码解析","date":"2020-06-05T23:51:18.000Z","updated":"2020-06-06T05:07:59.433Z","comments":true,"path":"2020/06/06/ThreadLocal应用及源码解析/","link":"","permalink":"https://lengmuyun.github.io/2020/06/06/ThreadLocal%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"类ThreadLocal提供线程本地变量。它与普通变量的区别在于，在不同的线程访问ThreadLocal(通过get或set方法)拥有自己的独立副本。ThreadLocal实例一般用private static修饰。 1.ThreadLocal用法1234567891011121314151617181920public class ThreadLocalTest &#123; // (1) 创建线程变量 private static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; // (2) 设置线程变量 threadLocal.set(\"hello world\"); // (3) 启动子线程 Thread thread = new Thread(() -&gt; &#123; // (4) 子线程输出变量的值 System.out.println(\"thread: \" + threadLocal.get()); &#125;); thread.start(); // (5) 主线程输出线程变量的值 System.out.println(\"main: \" + threadLocal.get()); &#125; &#125; 以上实例代码运行输出内容为: 12main: hello worldthread: null 代码(2)处设置了主线程的ThreadLocal副本值为hello world，故代码(5)输出为main: hello world;代码(4)处输出子线程中ThreadLocal副本值，因为在子线程中未进行设置，故输出thread: null。 2.源码分析123456789101112131415161718192021222324252627282930public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125;public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 2.1 set方法执行流程 2.2 get方法执行流程","categories":[],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://lengmuyun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"SpringBoot使用validation校验参数","slug":"SpringBoot使用validation校验参数","date":"2020-05-19T14:24:38.000Z","updated":"2020-05-21T13:23:19.943Z","comments":true,"path":"2020/05/19/SpringBoot使用validation校验参数/","link":"","permalink":"https://lengmuyun.github.io/2020/05/19/SpringBoot%E4%BD%BF%E7%94%A8validation%E6%A0%A1%E9%AA%8C%E5%8F%82%E6%95%B0/","excerpt":"","text":"当涉及校验用户输入时，如果由开发人员编码校验数据，那么验证数据的代码和业务逻辑代码会耦合在一起。Spring Framework 4.0支持Bean Validation 1.0(JSR-303)和Bean Validation 1.1(JSR-349)，也将其改写成了Spring的Validator接口。使用Spring Validation可以方便的进行数据校验。 1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 2.实体类中添加校验注解12345678910111213141516171819202122232425262728293031323334package io.github.lmy.springbootinaction.request;import io.github.lmy.springbootinaction.entity.User;import lombok.Data;import org.hibernate.validator.constraints.Range;import org.springframework.beans.BeanUtils;import javax.validation.constraints.Email;import javax.validation.constraints.NotBlank;import javax.validation.constraints.NotNull;import javax.validation.constraints.Pattern;@Datapublic class UserRequest &#123; @NotBlank(message = \"用户名不能为空\") private String name; @Range(min = 0, max = 150, message = \"年龄格式不正确\") @NotNull private Integer age; @Email(message = \"邮箱格式不正确\") @NotBlank(message = \"邮箱不能为空\") private String email; @Pattern(regexp = \"^1(3|4|5|7|8)\\\\d&#123;9&#125;$\", message = \"手机号码格式不正确\") @NotBlank(message = \"手机号不能为空\") private String phone; @NotBlank(message = \"密码不能为空\") private String password; &#125; 3.在Controller层校验数据 对需要校验的参数添加注解@Valid或@Validated，如果需要获取校验的信息，可以在被校验参数后面添加一个BindingResult参数，Spring会将校验的信息填充到该校验参数后面的BindingResult中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package io.github.lmy.springbootinaction.controller;import io.github.lmy.springbootinaction.request.LoginRequest;import io.github.lmy.springbootinaction.request.UserRequest;import io.github.lmy.springbootinaction.service.UserService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.validation.Valid;@Controller@RequestMapping(\"/user\")@Slf4jpublic class UserController &#123; @Autowired private UserService userService; @PostMapping(\"/register\") @ResponseBody public boolean register(@Valid @RequestBody UserRequest userRequest, BindingResult result) &#123; if (result.hasErrors()) &#123; for (FieldError fieldError : result.getFieldErrors()) &#123; log.info(\"field: &#123;&#125;, message: &#123;&#125;\", fieldError.getField(), fieldError.getDefaultMessage()); &#125; return false; &#125; boolean success = userService.register(userRequest); return success; &#125; @PostMapping(\"/login\") public String login(@Validated @RequestBody LoginRequest loginRequest) &#123; userService.login(loginRequest); return \"index\"; &#125;&#125; 4.校验失败统一处理 如果校验参数后没有BindingResult参数，且校验参数校验失败，则会抛出MethodArgumentNotValidException 异常。可以使用 @ExceptionHandler 注解统一处理参数校验失败。 1234567891011121314151617181920212223242526package io.github.lmy.springbootinaction.global;import org.springframework.http.HttpStatus;import org.springframework.validation.FieldError;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseStatus;import org.springframework.web.bind.annotation.RestControllerAdvice;import java.util.Map;import java.util.stream.Collectors;@RestControllerAdvicepublic class GlobalExceptionHandler &#123; @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(MethodArgumentNotValidException.class) public Map&lt;String, String&gt; handleValidationExceptions(MethodArgumentNotValidException ex) &#123; Map&lt;String, String&gt; result = ex.getBindingResult() .getFieldErrors() .stream() .collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage)); return result; &#125;&#125; 参考链接: 使用 spring validation 完成数据后端校验 SpringBoot 参数校验 Validation in Spring Boot","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lengmuyun.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lengmuyun.github.io/tags/Spring-Boot/"}]},{"title":"try-with-resource","slug":"try-with-resource","date":"2019-10-09T14:36:41.000Z","updated":"2019-10-11T14:46:12.526Z","comments":true,"path":"2019/10/09/try-with-resource/","link":"","permalink":"https://lengmuyun.github.io/2019/10/09/try-with-resource/","excerpt":"","text":"java7引入try-with-resource语法，允许在try代码块声明一个或多个资源，可以确保代码块执行完毕资源被关闭。 1.使用try-catch-finally在java7之前，我们需要在finally代码块来关闭资源，确保程序即使在try发生异常，资源也能正确的被关闭。 以下的例子，从硬盘中读取文件file.txt的内容，输出至控制台。 123456789101112131415161718192021@Testpublic void testTryCatchFinally() &#123; BufferedReader br = null; try &#123; br = new BufferedReader(new FileReader(new File(\"D://Resource/file.txt\"))); String line; while((line = br.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (br != null) &#123; br.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.使用try-with-resource替代从java7开始，你可以使用try-with-resource来替代try-catch-finally，简化代码。资源对象需要在try代码块中被声明和初始化，这样资源就会被自动的关闭。 try-with-resource语法使用的时候需要注意以下几点： try()代码块中可以声明一个或多个resource(resource是指那些实现了java.lang.AutoCloseable或java.io.Closeable的对象)，多个资源用分号分割 try-with-resource语法会自动处理资源的关闭，资源关闭的顺序跟声明的顺序相反 1234567891011@Testpublic void testTryWithResource() &#123; try(BufferedReader br = new BufferedReader(new FileReader(new File(\"D://Resource/file.txt\")))) &#123; String line; while((line = br.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 3.从字节码查看try-with-resource使用jd-gui查看方法testTryWithResource生成的字节码，可以看到try-with-resource主要做了一下2点处理 在finally代码块中执行了资源的关闭 如果在try代码块和finally代码块中都发生了异常，则会抛出try代码块捕获的异常，并抑制了finally代码块中异常 1234567891011121314151617181920212223242526272829@Testpublic void testTryWithResource() &#123; try &#123; BufferedReader br = new BufferedReader(new FileReader(new File(\"D://Resource/file.txt\")));Throwable localThrowable3 = null; try &#123; String line; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch (Throwable localThrowable1) &#123; localThrowable3 = localThrowable1;throw localThrowable1; &#125; finally &#123; if (br != null) &#123; if (localThrowable3 != null) &#123; try &#123; br.close(); &#125; catch (Throwable localThrowable2) &#123; localThrowable3.addSuppressed(localThrowable2); &#125; &#125; else &#123; br.close(); &#125; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 参考链接: Java – Try with Resources The Java™ Tutorials","categories":[{"name":"java","slug":"java","permalink":"https://lengmuyun.github.io/categories/java/"}],"tags":[]},{"title":"CentOS7安装MySQL","slug":"CentOS7安装MySQL","date":"2019-04-30T12:50:16.000Z","updated":"2020-06-06T08:31:41.773Z","comments":true,"path":"2019/04/30/CentOS7安装MySQL/","link":"","permalink":"https://lengmuyun.github.io/2019/04/30/CentOS7%E5%AE%89%E8%A3%85MySQL/","excerpt":"","text":"1.配置YUM源 1.1 下载YUM源rpm安装包 在MySQL官网中下载YUM源rpm安装包：http://dev.mysql.com/downloads/repo/yum/ 1.2 安装mysql源 1yum localinstall mysql80-community-release-el7-3.noarch.rpm 1.3 检查mysql源是否安装成功 1yum repolist enabled | grep \"mysql.*-community.*\" 看到上图所示表示安装成功。 1.4 修改默认安装的mysql版本 当前文件的mysql版本为5.6，若要改为5.7，则将5.7的enabled改为1，将5.6的enabled改为0即可。 2.安装MySQL1yum install mysql-community-server 3.启动MySQL1234# 启动MySQLsystemctl start mysqld# 查看MySQL启动状态systemctl status mysqld 4.修改root用户密码 4.1 直接输入mysql就可以进入MySQL了 4.2 修改root用户密码 1set password &#x3D; password(&#39;root&#39;); 5.开启用户远程访问1GRANT ALL PRIVILEGES ON *.*TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;root&#39; WITH GRANT OPTION; 6.开放3306端口开启端口后，可以在外部使用mysql连接工具连接，具体操作如下: 12345678# 查看防火墙状态firewall-cmd --state# 在running状态下，向firewall添加需要开放的端口firewall-cmd --permanent --zone=public --add-port=3306/tcp# 加载配置，使得修改有效firewall-cmd --reload# 查看开启的端口，出现3306/tcp则开启正确firewall-cmd --permanent --zone=public --list-ports 参考链接: MySQL5.7安装与配置（YUM） CentOS之Mysql已经开放了3306端口，外网访问不上 Linux下安装MySQL","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://lengmuyun.github.io/categories/CentOS/"}],"tags":[]},{"title":"CentOS7安装Tomcat","slug":"CentOS7安装Tomcat","date":"2019-04-26T23:19:00.000Z","updated":"2020-06-06T08:36:35.260Z","comments":true,"path":"2019/04/27/CentOS7安装Tomcat/","link":"","permalink":"https://lengmuyun.github.io/2019/04/27/CentOS7%E5%AE%89%E8%A3%85Tomcat/","excerpt":"","text":"1.检查JDK环境通过java -version命令检查系统是否安装JDK 1java -version 2.下载Tomcat及安装 2.1 去Apache Tomcat官网下载Tomcat9 2.2 使用WinSCP上传安装包至/usr/local/目录下 2.3 安装tomcat 123456# 解压压缩包tar -zxvf apache-tomcat-9.0.19.tar.gz# 删除压缩包rm apache-tomcat-9.0.19.tar.gz# 重命名mv apache-tomcat-9.0.19 tomcat-9.0.19 3.启动Tomcat 3.1 启动tomcat 1/usr/local/tomcat-9.0.19/bin/startup.sh 3.2 查看tomcat进程 1ps -ef|grep java 3.3 查看tomcat欢迎页 1curl http://localhost:8080 4.配置端口在linux上开启的tomcat使用浏览器访问不了。主要原因在于防火墙的存在，导致的端口无法访问。CentOS7使用firewall而不是iptables。所以解决这类问题可以通过添加firewall的端口，使其对我们需要用的端口开放。 4.1 查看防火墙状态 1firewall-cmd --state 4.2 在running 状态下，向firewall 添加需要开放的端口 12# 永久的添加该端口。去掉--permanent则表示临时。firewall-cmd --permanent --zone=public --add-port=8080/tcp 4.3 加载配置，使得修改有效 1firewall-cmd --reload 4.4 查看开启的端口，出现8080/tcp则开启正确 1firewall-cmd --permanent --zone=public --list-ports 4.5 端口添加完后可以外部浏览器访问 参考链接: centos7.4安装jdk1.8及tomcat8.5 CentOS7上解决tomcat不能被外部浏览访问 CentOS 7 安装 Tomcat 8 的方法","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://lengmuyun.github.io/categories/CentOS/"}],"tags":[]},{"title":"CentOS7安装JDK8","slug":"CentOS7安装JDK8","date":"2019-04-20T01:39:08.000Z","updated":"2020-06-06T08:38:01.015Z","comments":true,"path":"2019/04/20/CentOS7安装JDK8/","link":"","permalink":"https://lengmuyun.github.io/2019/04/20/CentOS7%E5%AE%89%E8%A3%85JDK8/","excerpt":"","text":"1.下载JDK去Oracle官网下载JDK8，根据CentOS的版本下载对应的32位或64位安装包。 查看CentOS是32位还是64位可以用以下命令（如果有x86_64就是64位的，没有就是32位的；后面是X686或X86_64则内核是64位的，i686或i386则内核是32位的） 1uname -a # 用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等） 在centos系统中执行uname -a指令，系统为64位，下载文件jdk-8u211-linux-x64.tar.gz 2.传输文件及解压 2.1 在/usr/local/下建立java文件夹，使用WinSCP上传jdk至java文件夹里面 2.2 解压文件 1tar -zxvf jdk-8u211-linux-x64.tar.gz 2.3 删除压缩包 1rm jdk-8u211-linux-x64.tar.gz 3.配置环境变量 3.1 修改/etc/profile文件 1vi /etc/profile 3.2 在文件末尾追加以下内容 1234567# 配置JAVA_HOME环境变量export JAVA_HOME=/usr/local/java/jdk1.8.0_211# 在PATH路径上追加$JAVA_HOME/bin目录export PATH=$JAVA_HOME/bin:$PATH# 配置CLASSPATH，tools.jar用于编译，dt.jar是Swing需要用到的# 如果CLASSPATH中不包括当前路径.，JRE就不会在当前路径下搜索Java类export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 3.3 使文件修改生效 12# source命令也称为“点命令”，也就是一个点符号（.）,是bash的内部命令。 source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。source /etc/profile 4.查看安装jdk是否成功1java -version 参考链接: centos7.4安装jdk1.8及tomcat8.5 Java 环境变量你真的明白吗？","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://lengmuyun.github.io/categories/CentOS/"}],"tags":[]},{"title":"MySQL操作数据表的记录","slug":"MySQL操作数据表的记录","date":"2019-03-30T10:11:19.000Z","updated":"2019-03-30T10:12:01.696Z","comments":true,"path":"2019/03/30/MySQL操作数据表的记录/","link":"","permalink":"https://lengmuyun.github.io/2019/03/30/MySQL%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E8%AE%B0%E5%BD%95/","excerpt":"","text":"INSERT 标准插入语法 1INSERT [INTO] tbl_name [(col_name,...)] &#123;VALUES|VALUE&#125; (&#123;expr|DEFAULT&#125;,...),(...),... 可以使用子查询，但是不能插入多条记录 1INSERT [INTO] tbl_name SET col_name=&#123;expr|DEFAULT&#125;,... 可以将查询结果插入到指定数据表 1INSERT [INTO] tbl_name [(col_name,...)] SELECT ... UPDATE 1UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1=&#123;expr1|DEFAULT&#125; [,col_name2=&#123;expr2|DEFAULT&#125;] ... [WHERE where_condition] DELETE 1DELETE FROM tbl_name [WHERE where_condition] SELECT 123456789SELECT select_expr [,select_expr ...][ FROM table_references [WHERE where_condition] [GROUP BY &#123;col_name|position&#125; [ASC|DESC], ...] [HAVING where_condition] [ORDER BY &#123;col_name|expr|position&#125; [ASC|DESC], ...] [LIMIT &#123;[offset,] row_count&#125;|row_count OFFSET offset]] 查询表达式(select_expr) 每一个表达式表示想要的一列，必须有至少一个。 多个列之间以英文逗号分隔。 星号(*)表示所有列。tbl_name. *可以表示命名表的所有列。 查询表达式可以用[AS] alias_name为其赋予别名。 别名可用于GROUP BY, ORDER BY或HAVING字句。 WHERE条件表达式 对记录进行过滤，如果没有指定WHERE子句，则显示所有记录。 在WHERE表达式中，可以使用MySQL支持的函数或运算符。","categories":[{"name":"MySQL笔记","slug":"MySQL笔记","permalink":"https://lengmuyun.github.io/categories/MySQL%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"MySQL约束以及修改数据表","slug":"MySQL约束以及修改数据表","date":"2019-03-24T13:43:18.000Z","updated":"2019-03-30T11:02:04.565Z","comments":true,"path":"2019/03/24/MySQL约束以及修改数据表/","link":"","permalink":"https://lengmuyun.github.io/2019/03/24/MySQL%E7%BA%A6%E6%9D%9F%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E8%A1%A8/","excerpt":"","text":"约束 1.约束保证数据的完整性和一致性。 2.约束分为表级约束和列级约束。 3.约束类型包括：NOT NULL(非空约束)PRIMARY KEY(主键约束)UNIQUE KEY(唯一约束)DEFAULT(默认约束)FOREIGN KEY(外键约束)外键约束 保证数据一致性，完整性。实现一对一或一对多关系。 外键约束的要求 1.父表和子表必须使用相同的存储引擎，而且禁止使用临时表。2.数据表的存储引擎只能为InnoDB。3.外键列和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同。4.外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将自动创建索引。 编辑数据表的默认存储引擎 MySQL配置文件 1default-storage-engine=INNODB 外键约束的参照操作 参考操作 说明 CASCADE 从父表删除或更新且自动删除或更新子表中匹配的行 SET NULL 从父表删除或更新行，并设置子表中的外键列为NULL。如果使用该选项，必须保证子表列没有指定NOT NULL RESTRICT 拒绝对父表的删除或更新操作 NO ACTION 标准SQL的关键字，在MySQL中与RESTRICT相同 表级约束与列级约束 对一个数据列建立的约束，称为列级约束。对多个数据列建立的约束，称为表级约束。列级约束既可以在列定义时声明，也可以在列定义后声明。表级约束只能在列定义后声明。 修改数据表 添加单列 1ALTER TABLE tbl_name ADD [COLUMN] col_name column_definition [FIRST | AFTER col_name] 添加多列 1ALTER TABLE tbl_name ADD [COLUMN] (col_name column_definition,...) 删除列 1ALTER TABLE tbl_name DROP [COLUMN] col_name 对某张表执行多个动作，如删除多列 1ALTER TABLE tbl_name DROP [COLUMN] col_name, DROP [COLUMN] col_name 添加主键约束 1ALTER TABLE tbl_name ADD [CONSTRAINT[symbol]] PRIMARY KEY [index_type] (index_col_name,...) 添加唯一约束 1ALTER TABLE tbl_name ADD [CONSTRAINT[symbol]] UNIQUE [INDEX|KEY] [index_name] [index_type] (index_col_name,...) 添加外键约束 1ALTER TABLE tbl_name ADD [CONSTRAINT[symbol]] FOREIGN KEY [index_name] (index_col_name) REFERENCES tbl_name (col_namme) 添加或删除默认约束 1ALTER TABLE tbl_name ALTER [COLUMN] col_name &#123;SET DEFAULT literal|DROP DEFAULT&#125; 删除主键约束 1ALTER TABLE tbl_name DROP PRIMARY KEY 删除唯一约束 1ALTER TABLE tbl_name DROP &#123;INDEX|KEY&#125; index_name 删除外键约束 1ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol 修改列定义 1ALTER TABLE tbl_name MODIFY [COLUMN] col_name column_definition [FIRST|AFTER col_name] 修改列名称 1ALTER TABLE tbl_name CHANGE [COLUMN] old_col_name new_col_name column_definition [FIRST|AFTER col_name] 修改表名 12ALTER TABLE tbl_name RENAME [TO|AS] new_tbl_nameRENAME TABLE tbl_name TO new_tbl_name [,tbl_name2 TO new_tbl_name2]...","categories":[{"name":"MySQL笔记","slug":"MySQL笔记","permalink":"https://lengmuyun.github.io/categories/MySQL%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"MySQL操作数据表与约束","slug":"MySQL操作数据表与约束","date":"2019-03-24T05:10:06.000Z","updated":"2019-03-24T13:39:50.209Z","comments":true,"path":"2019/03/24/MySQL操作数据表与约束/","link":"","permalink":"https://lengmuyun.github.io/2019/03/24/MySQL%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E8%A1%A8%E4%B8%8E%E7%BA%A6%E6%9D%9F/","excerpt":"","text":"1. MySQL操作数据表1.1 创建数据表1234CREATE TABLE [IF NOT EXISTS] table_name ( column_name data_type, ...) 1.2 查看数据表列表1SHOW TABLES [FROM db_name] [LIKE 'pattern' | WHERE expr] 1.3 查看数据表结构1SHOW COLUMNS FROM tbl_name; 1.4 插入记录1INSERT [INTO] tbl_name [(col_name,...)] VALUES(val,...); 1.5 记录查找1SELECT expr,... FROM tbl_name; 2. MySQL约束2.1 空值与非空 NULL, 字段值可以为空NOT NULL,字段值禁止为空 2.2 AUTO_INCREMENT 自动编号，且必须与主键组合使用默认情况下，起始值为1，每次增量为1 2.3 主键约束(PRIMARY KEY) 每张数据表只能存在一个主键主键保证记录的唯一性主键自动为NOT NULL 2.4 唯一约束(UNIQUE KEY) 唯一约束可以保证记录的唯一性唯一约束的字段可以为空值(NULL)每张数据表可以存在多个唯一约束 2.5 默认值(DEFAULT) 当插入记录时，如果没有明确为字段赋值，则自动赋予默认值。","categories":[{"name":"MySQL笔记","slug":"MySQL笔记","permalink":"https://lengmuyun.github.io/categories/MySQL%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"MySQL数据类型","slug":"MySQL数据类型","date":"2019-03-23T13:49:58.000Z","updated":"2019-03-23T13:50:45.901Z","comments":true,"path":"2019/03/23/MySQL数据类型/","link":"","permalink":"https://lengmuyun.github.io/2019/03/23/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"MySQL数据类型 MySQL中定义数据字段的类型对你数据库的优化是非常重要的。MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。 1.数值类型 MySQL支持所有标准SQL数值数据类型。BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。 类型 大小(字节) 范围(有符号) 范围(无符号) TINYINT 1 (-128，127) (0，255) SMALLINT 2 (-32 768，32 767) (0，65 535) MEDIUMINT 3 (-2^23，2^23-1) (0，2^24-1) INT 4 (-2^31，2^31-1) (0，2^32-1) BIGINT 8 (-2^63，2^63-1) (0，2^64-1) FLOAT[(M,D)] 4 M是数字总位数，D是小数点后面的位数。 DOUBLE[(M,D)] 8 2.日期和时间类型 表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小(字节) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 3.字符串类型 字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。 类型 大小(字节) 用途 CHAR 0-255 定长字符串 VARCHAR 0-65535 变长字符串 TINYBLOB 0-255 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 短文本字符串 BLOB 0-65 535 二进制形式的长文本数据 TEXT 0-65 535 长文本数据 MEDIUMBLOB 0-16 777 215 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 中等长度文本数据 LONGBLOB 0-4 294 967 295 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 极大文本数据","categories":[{"name":"MySQL笔记","slug":"MySQL笔记","permalink":"https://lengmuyun.github.io/categories/MySQL%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"初涉MySQL","slug":"初涉MySQL","date":"2019-03-21T23:50:47.000Z","updated":"2019-03-24T05:12:22.313Z","comments":true,"path":"2019/03/22/初涉MySQL/","link":"","permalink":"https://lengmuyun.github.io/2019/03/22/%E5%88%9D%E6%B6%89MySQL/","excerpt":"","text":"1-1 MySQL概述 MySQL由瑞典MySQL AB公司开发，目前属于Oracle公司。 MySQL是一个开源的关系型数据库管理系统。 MySQL分为社区版和企业版。 1-3 启动与停止MySQL服务 启动MySQL服务 1net start MySQL 关闭MySQL服务 1net stop MySQL 1-4 MySQL登陆与退出 MySQL登陆 1mysql 参数 参数 描述 -D, –database=name 打开指定数据库 –delimiter=name 指定分隔符 -h, –host=name 服务器名称 -p, –password[=name] 密码 -P, –port=# 端口号 –prompt=name 设置提示符 -u, –user=name 用户名 -V, –version 输出版本信息并且退出 MySQL退出 123exit;quit;\\q; 1-5 修改MySQL提示符 连接客户端时通过参数指定 1mysql -uroot -proot --prompt 提示符 连接上客户端后，通过prompt命令修改 1prompt 提示符 参数 描述 \\D 完整的日期 \\d 当前数据库 \\h 服务器名称 \\u 当前用户 1-6 MySQL常用命令以及语法规范 显示当前服务器版本 1SELECT VERSION(); 显示当前日期时间 1SELECT NOW(); 显示当前用户 1SELECT USER(); MySQL语句的规范 关键字与函数名称全部大写数据库名称，表名称，字段名称全部小写SQL语句必须以分号结尾 1-7 操作数据库 创建数据库 1CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset_name 查看数据库列表 1SHOW &#123;DATABASES | SCHEMAS&#125; [LIKE 'pattern' | WHERE expr] 查看警告 1SHOW WARNINGS; 查看建数据库语句 1SHOW CREATE DATABASE db_name; 修改数据库 12ALTER &#123;DATABASE | SCHEMA&#125; [db_name][DEFAULT] CHARACTER SET [=] charset_name; 删除数据库 1DROP &#123;DATABASE | SCHEMA&#125; [IF EXISTS] db_name； 打开数据库 1USE db_name; 查看打开的数据库 1SELECT DATABASE();","categories":[{"name":"MySQL笔记","slug":"MySQL笔记","permalink":"https://lengmuyun.github.io/categories/MySQL%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"TCP三次握手四次挥手","slug":"TCP三次握手四次挥手","date":"2019-01-06T06:45:04.000Z","updated":"2020-06-06T08:38:59.043Z","comments":true,"path":"2019/01/06/TCP三次握手四次挥手/","link":"","permalink":"https://lengmuyun.github.io/2019/01/06/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","excerpt":"","text":"1.TCP报文首部 TCP报文首部格式如下图所示 序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始； 确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701； 确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1； 同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1； 终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放； 2.TCP三次握手 TCP客户进程向服务器发出连接请求报文，报文首部中的同步位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。 TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了 SYN-RCVD（同步收到）状态。 TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入 ESTABLISHED（已建立连接）状态。当服务器收到客户端的确认后也进入 ESTABLISHED状态，此后双方就可以开始通信了。 3.TCP四次挥手 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。服务器只要收到了客户端发出的确认，立即进入CLOSED状态。 参考链接: https://blog.csdn.net/qzcsu/article/details/72861891","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://lengmuyun.github.io/tags/http/"}]},{"title":"Java内存区域和内存溢出异常","slug":"Java内存区域和内存溢出异常","date":"2018-07-01T14:34:01.000Z","updated":"2018-07-02T04:46:16.308Z","comments":true,"path":"2018/07/01/Java内存区域和内存溢出异常/","link":"","permalink":"https://lengmuyun.github.io/2018/07/01/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/","excerpt":"","text":"2.2 运行时数据区域 Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。 2.2.1 程序计数器 程序计数器(Program Counter Register)是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。 在虚拟机的概念模型里(仅是概念模型，各种虚拟机的可能会通过一些更高效的方式去实现)，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 2.2.2 Java虚拟机栈 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型(boolean，byte，char，short，int，float，long，double)、对象引用(reference类型，它不等同于对象本身，可能是一条指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。 2.2.3 本地方法栈 本地方法栈(Native Method Stack)与虚拟机栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈是为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的Native方法服务。 2.2.4 Java堆 所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。 Java堆还可以细分为：新生代和老年代；再细致一点的有：Eden空间、From Survivor空间、To Survivor空间等。 2.2.5 方法区 方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 2.2.6 运行时常量池 运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。","categories":[{"name":"深入理解Java虚拟机笔记","slug":"深入理解Java虚拟机笔记","permalink":"https://lengmuyun.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"第九章-用正则表达式进行搜索","slug":"第九章-用正则表达式进行搜索","date":"2018-05-21T23:46:31.000Z","updated":"2018-05-31T15:11:36.136Z","comments":true,"path":"2018/05/22/第九章-用正则表达式进行搜索/","link":"","permalink":"https://lengmuyun.github.io/2018/05/22/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/","excerpt":"","text":"9.1 正则表达式介绍 正则表达式是用来匹配文本的特殊的串（字符集合） 9.2 使用MySQL正则表达式 正则表达式的作用是匹配文本，将一个模式（正则表达式）与一个文本串进行比较。。MySQL用WHERE子句对正则表达式提供了初步的支持，允许你指定正则表达式，过滤SELECT检索出的数据。 9.2.1 基本字符匹配 检索列prod_name包含文本1000的所有行 1234SELECT prod_id, prod_nameFROM productsWHERE prod_name REGEXP '1000'ORDER BY prod_name; 9.2.2 进行OR匹配 为搜索两个串之一（或者为这个串，或者为另一个串），使用|; |为正则表达式的OR操作符; 使用|从功能上类似于在SELECT语句中使用OR语句，多个OR条件可并入单个正则表达式。 检索列prod_name包含1000或2000的所有行 1234SELECT prod_id, prod_nameFROM productsWHERE prod_name REGEXP '1000|2000'ORDER BY prod_name; 9.2.3 匹配几个字符之一 可通过指定一组用[和]括起来的字符来完成匹配特定的字符 []是另一种形式的OR语句。正则表达式[123] Ton为[1|2|3] Ton的缩写，也可以使用后者 1234SELECT prod_id, prod_nameFROM productsWHERE prod_name REGEXP '[123] ton'ORDER BY prod_name; prod_id prod_name ANV02 1 ton anvil ANV03 2 ton anvil 除非把字符|括在一个集合中，否则它将应用于整个串 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '1|2|3 ton'ORDER BY prod_name; prod_name 1 ton anvil 2 ton anvil JetPack 1000 JetPack 2000 TNT (1 stick) 字符集合也可以被否定，即，它们将匹配除指定字符外的任何东西。为否定一个字符集，在集合的开始处放置一个^即可。[^123]却匹配除这些字符外的任何东西。 9.2.4 匹配范围 集合可用来定义要匹配的一个或多个字符。 下面的集合将匹配数字0到9：[0123456789]，等同于[0-9]；[a-z]匹配任意字母字符。 例子 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '[1-5] ton'ORDER BY prod_name; 9.2.5 匹配特殊字符 正则表达式语言由具有特定含义的特殊字符构成。匹配这些字符.，[]，|和-应该怎么办 为了匹配特殊字符，必须用\\为前导。\\-表示查找-，\\.表示查找. 正则表达式内具有特殊意义的所有字符都必须以这种方式转义。这包括.、|、[]以及迄今为止使用过的其他特殊字符。 找出包含.字符的值 123SELECT vend_nameFROM vendorsWHERE vend_name REGEXP '.'; vend_name Anvils R Us LT Supplies ACME Furball Inc. Jet Set Jouets Et Ours 123SELECT vend_nameFROM vendorsWHERE vend_name REGEXP '\\\\.'; vend_name Furball Inc. #### 9.2.6 匹配字符类 预定义的字符集，称为字符类（character class）。(见MySQL必知必会p58) 9.2.7 匹配多个实例 表9-3 重复元字符 元字符 说明 * 0个或多个匹配 + 1个或多个匹配(等于{1,}) ? 0个或1个匹配(等于{0,1}) {n} 指定数目的匹配 {n,} 不少于指定数目的匹配 {n,m} 匹配数目的范围(m不超过255) [0-9]匹配任意数字（这个例子中为1和5），sticks?匹配stick和sticks（s后的?使s可选，因为?匹配它前面的任何字符的0次或1次出现），\\)匹配)。 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '\\\\([1-5] sticks?\\\\)'ORDER BY prod_name; prod_name TNT (1 stick) TNT (5 sticks) [:digit:]匹配任意数字，{4}确切地要求它前面的字符（任意数字）出现4次，所以[[:digit:]]{4}匹配连在一起的任意4位数字。 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '[[:digit:]]&#123;4&#125;'ORDER BY prod_name; 9.2.8 定位符 表9-4 定位元字符 元字符 说明 ^ 文本的开始 $ 文本的结束 [[:&lt;:]] 词的开始 [[:&gt;:]] 词的结束 找出以一个数（包括以小数点开始的数）开始的所有产品 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '^[0-9\\\\.]'ORDER BY prod_name; prod_name .5 ton anvil 1 ton anvil 2 ton anvil","categories":[{"name":"MySQL必知必会笔记","slug":"MySQL必知必会笔记","permalink":"https://lengmuyun.github.io/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"第八章-用通配符进行过滤","slug":"第八章-用通配符进行过滤","date":"2018-05-21T23:41:02.000Z","updated":"2018-05-31T15:03:35.207Z","comments":true,"path":"2018/05/22/第八章-用通配符进行过滤/","link":"","permalink":"https://lengmuyun.github.io/2018/05/22/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4/","excerpt":"","text":"8.1 LIKE操作符8.1.1 百分号(%)通配符 最常使用的通配符是百分号（%）。在搜索串中，%表示任何字符出现任意次数。 %代表搜索模式中给定位置的0个、1个或多个字符。 找出所有以词jet起头的产品 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE 'jet%'; 找出所有以词包含文本anvil的产品 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE '%anvil%'; 找出以s起头以e结尾的所有产品 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE 's%e'; 1.注意尾空格 在保存词anvil 时， 如果它后面有一个或多个空格， 则子句WHERE prod_name LIKE ‘%anvil’将不会匹配它们; 2.注意NULL 虽然似乎%通配符可以匹配任何东西，但有一个例外，即NULL。 8.1.2 下划线(_)通配符 另一个有用的通配符是下划线（_）。下划线的用途与%一样，但下划线只匹配单个字符而不是多个字符。 以下划线(_)通配符检索数据 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE '_ ton anvil'; prod_id prod_name ANV02 1 ton anvil ANV03 2 ton anvil 以百分号(%)通配符检索数据 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE '% ton anvil'; prod_id prod_name ANV01 .5 ton anvil ANV02 1 ton anvil ANV03 2 ton anvil 使用通配符的技巧 MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。","categories":[{"name":"MySQL必知必会笔记","slug":"MySQL必知必会笔记","permalink":"https://lengmuyun.github.io/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Tomcat开启gzip压缩","slug":"Tomcat开启gzip压缩","date":"2018-04-04T13:16:20.000Z","updated":"2018-04-04T13:21:15.962Z","comments":true,"path":"2018/04/04/Tomcat开启gzip压缩/","link":"","permalink":"https://lengmuyun.github.io/2018/04/04/Tomcat%E5%BC%80%E5%90%AFgzip%E5%8E%8B%E7%BC%A9/","excerpt":"","text":"一、原理介绍HTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求服务器对应资源后，从服务器端将资源文件压缩，再输出到客户端，由客户端的浏览器负责解压缩并浏览。相对于普通的浏览过程HTML ,CSS,Javascript , Text ，它可以节省40%左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，压缩效率也很高。 二、Tomcat配置编辑tomcat目录下的conf/server.xml 123&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 改为: 1234567&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" URIEncoding=\"UTF-8\" compression=\"on\" noCompressionUserAgents=\"gozilla, traviata\" compressableMimeType=\"text/html,text/javascript,text/css\" /&gt; 参数说明: 12345compression=\"on\" 打开压缩功能。compressionMinSize=\"2048\" 启用压缩的输出内容大小，这里面默认为2KB。noCompressionUserAgents=\"gozilla, traviata\" 对于这些浏览器，不启用压缩。compressableMimeType=\"text/html,text/xml\" 压缩类型。URIEncoding=\"UTF-8\" 设置编码为UTF-8。 三、测试对同一个接口，开启gzip压缩和不开启gzip压缩进行测试，不开启gzip，接收数据1.5MB，而开启gzip压缩后接收数据86.4KB，压缩率94% 参考链接: https://blog.csdn.net/qing_gee/article/details/51538598 https://my.oschina.net/refresh/blog/90986","categories":[],"tags":[]}],"categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lengmuyun.github.io/categories/Spring-Boot/"},{"name":"java","slug":"java","permalink":"https://lengmuyun.github.io/categories/java/"},{"name":"CentOS","slug":"CentOS","permalink":"https://lengmuyun.github.io/categories/CentOS/"},{"name":"MySQL笔记","slug":"MySQL笔记","permalink":"https://lengmuyun.github.io/categories/MySQL%E7%AC%94%E8%AE%B0/"},{"name":"深入理解Java虚拟机笔记","slug":"深入理解Java虚拟机笔记","permalink":"https://lengmuyun.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/"},{"name":"MySQL必知必会笔记","slug":"MySQL必知必会笔记","permalink":"https://lengmuyun.github.io/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://lengmuyun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lengmuyun.github.io/tags/Spring-Boot/"},{"name":"http","slug":"http","permalink":"https://lengmuyun.github.io/tags/http/"}]}