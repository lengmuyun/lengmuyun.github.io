{"meta":{"title":"lengmuyun's Blog","subtitle":"锲而不舍，金石可镂","description":null,"author":"lengmuyun","url":"https://lengmuyun.github.io"},"pages":[{"title":"categories","date":"2018-05-21T23:31:34.000Z","updated":"2018-05-21T23:35:30.957Z","comments":false,"path":"categories/index.html","permalink":"https://lengmuyun.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-21T23:44:37.000Z","updated":"2018-05-21T23:45:11.727Z","comments":true,"path":"tags/index.html","permalink":"https://lengmuyun.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java内存区域和内存溢出异常","slug":"Java内存区域和内存溢出异常","date":"2018-07-01T14:34:01.000Z","updated":"2018-07-02T04:46:16.308Z","comments":true,"path":"2018/07/01/Java内存区域和内存溢出异常/","link":"","permalink":"https://lengmuyun.github.io/2018/07/01/Java内存区域和内存溢出异常/","excerpt":"","text":"2.2 运行时数据区域 Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。 2.2.1 程序计数器 程序计数器(Program Counter Register)是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。 在虚拟机的概念模型里(仅是概念模型，各种虚拟机的可能会通过一些更高效的方式去实现)，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 2.2.2 Java虚拟机栈 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型(boolean，byte，char，short，int，float，long，double)、对象引用(reference类型，它不等同于对象本身，可能是一条指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。 2.2.3 本地方法栈 本地方法栈(Native Method Stack)与虚拟机栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈是为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的Native方法服务。 2.2.4 Java堆 所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。 Java堆还可以细分为：新生代和老年代；再细致一点的有：Eden空间、From Survivor空间、To Survivor空间等。 2.2.5 方法区 方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 2.2.6 运行时常量池 运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。","categories":[{"name":"深入理解Java虚拟机笔记","slug":"深入理解Java虚拟机笔记","permalink":"https://lengmuyun.github.io/categories/深入理解Java虚拟机笔记/"}],"tags":[]},{"title":"第九章-用正则表达式进行搜索","slug":"第九章-用正则表达式进行搜索","date":"2018-05-21T23:46:31.000Z","updated":"2018-05-31T15:11:36.136Z","comments":true,"path":"2018/05/22/第九章-用正则表达式进行搜索/","link":"","permalink":"https://lengmuyun.github.io/2018/05/22/第九章-用正则表达式进行搜索/","excerpt":"","text":"9.1 正则表达式介绍 正则表达式是用来匹配文本的特殊的串（字符集合） 9.2 使用MySQL正则表达式 正则表达式的作用是匹配文本，将一个模式（正则表达式）与一个文本串进行比较。。MySQL用WHERE子句对正则表达式提供了初步的支持，允许你指定正则表达式，过滤SELECT检索出的数据。 9.2.1 基本字符匹配 检索列prod_name包含文本1000的所有行 1234SELECT prod_id, prod_nameFROM productsWHERE prod_name REGEXP '1000'ORDER BY prod_name; 9.2.2 进行OR匹配 为搜索两个串之一（或者为这个串，或者为另一个串），使用|; |为正则表达式的OR操作符; 使用|从功能上类似于在SELECT语句中使用OR语句，多个OR条件可并入单个正则表达式。 检索列prod_name包含1000或2000的所有行 1234SELECT prod_id, prod_nameFROM productsWHERE prod_name REGEXP '1000|2000'ORDER BY prod_name; 9.2.3 匹配几个字符之一 可通过指定一组用[和]括起来的字符来完成匹配特定的字符 []是另一种形式的OR语句。正则表达式[123] Ton为[1|2|3] Ton的缩写，也可以使用后者 1234SELECT prod_id, prod_nameFROM productsWHERE prod_name REGEXP '[123] ton'ORDER BY prod_name; prod_id prod_name ANV02 1 ton anvil ANV03 2 ton anvil 除非把字符|括在一个集合中，否则它将应用于整个串 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '1|2|3 ton'ORDER BY prod_name; prod_name 1 ton anvil 2 ton anvil JetPack 1000 JetPack 2000 TNT (1 stick) 字符集合也可以被否定，即，它们将匹配除指定字符外的任何东西。为否定一个字符集，在集合的开始处放置一个^即可。[^123]却匹配除这些字符外的任何东西。 9.2.4 匹配范围 集合可用来定义要匹配的一个或多个字符。 下面的集合将匹配数字0到9：[0123456789]，等同于[0-9]；[a-z]匹配任意字母字符。 例子 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '[1-5] ton'ORDER BY prod_name; 9.2.5 匹配特殊字符 正则表达式语言由具有特定含义的特殊字符构成。匹配这些字符.，[]，|和-应该怎么办 为了匹配特殊字符，必须用\\为前导。\\-表示查找-，\\.表示查找. 正则表达式内具有特殊意义的所有字符都必须以这种方式转义。这包括.、|、[]以及迄今为止使用过的其他特殊字符。 找出包含.字符的值 123SELECT vend_nameFROM vendorsWHERE vend_name REGEXP '.'; vend_name Anvils R Us LT Supplies ACME Furball Inc. Jet Set Jouets Et Ours 123SELECT vend_nameFROM vendorsWHERE vend_name REGEXP '\\\\.'; vend_name Furball Inc. 9.2.6 匹配字符类 预定义的字符集，称为字符类（character class）。(见MySQL必知必会p58) 9.2.7 匹配多个实例 表9-3 重复元字符 元字符 说明 * 0个或多个匹配 + 1个或多个匹配(等于{1,}) ? 0个或1个匹配(等于{0,1}) {n} 指定数目的匹配 {n,} 不少于指定数目的匹配 {n,m} 匹配数目的范围(m不超过255) [0-9]匹配任意数字（这个例子中为1和5），sticks?匹配stick和sticks（s后的?使s可选，因为?匹配它前面的任何字符的0次或1次出现），\\)匹配)。 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '\\\\([1-5] sticks?\\\\)'ORDER BY prod_name; prod_name TNT (1 stick) TNT (5 sticks) [:digit:]匹配任意数字，{4}确切地要求它前面的字符（任意数字）出现4次，所以[[:digit:]]{4}匹配连在一起的任意4位数字。 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '[[:digit:]]&#123;4&#125;'ORDER BY prod_name; 9.2.8 定位符 表9-4 定位元字符 元字符 说明 ^ 文本的开始 $ 文本的结束 [[:&lt;:]] 词的开始 [[:&gt;:]] 词的结束 找出以一个数（包括以小数点开始的数）开始的所有产品 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '^[0-9\\\\.]'ORDER BY prod_name; prod_name .5 ton anvil 1 ton anvil 2 ton anvil","categories":[{"name":"MySQL必知必会笔记","slug":"MySQL必知必会笔记","permalink":"https://lengmuyun.github.io/categories/MySQL必知必会笔记/"}],"tags":[]},{"title":"第八章-用通配符进行过滤","slug":"第八章-用通配符进行过滤","date":"2018-05-21T23:41:02.000Z","updated":"2018-05-31T15:03:35.207Z","comments":true,"path":"2018/05/22/第八章-用通配符进行过滤/","link":"","permalink":"https://lengmuyun.github.io/2018/05/22/第八章-用通配符进行过滤/","excerpt":"","text":"8.1 LIKE操作符8.1.1 百分号(%)通配符 最常使用的通配符是百分号（%）。在搜索串中，%表示任何字符出现任意次数。 %代表搜索模式中给定位置的0个、1个或多个字符。 找出所有以词jet起头的产品 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE 'jet%'; 找出所有以词包含文本anvil的产品 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE '%anvil%'; 找出以s起头以e结尾的所有产品 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE 's%e'; 1.注意尾空格 在保存词anvil 时， 如果它后面有一个或多个空格， 则子句WHERE prod_name LIKE ‘%anvil’将不会匹配它们; 2.注意NULL 虽然似乎%通配符可以匹配任何东西，但有一个例外，即NULL。 8.1.2 下划线(_)通配符 另一个有用的通配符是下划线（_）。下划线的用途与%一样，但下划线只匹配单个字符而不是多个字符。 以下划线(_)通配符检索数据 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE '_ ton anvil'; prod_id prod_name ANV02 1 ton anvil ANV03 2 ton anvil 以百分号(%)通配符检索数据 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE '% ton anvil'; prod_id prod_name ANV01 .5 ton anvil ANV02 1 ton anvil ANV03 2 ton anvil 使用通配符的技巧 MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。","categories":[{"name":"MySQL必知必会笔记","slug":"MySQL必知必会笔记","permalink":"https://lengmuyun.github.io/categories/MySQL必知必会笔记/"}],"tags":[]},{"title":"Tomcat开启gzip压缩","slug":"Tomcat开启gzip压缩","date":"2018-04-04T13:16:20.000Z","updated":"2018-04-04T13:21:15.962Z","comments":true,"path":"2018/04/04/Tomcat开启gzip压缩/","link":"","permalink":"https://lengmuyun.github.io/2018/04/04/Tomcat开启gzip压缩/","excerpt":"","text":"一、原理介绍HTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求服务器对应资源后，从服务器端将资源文件压缩，再输出到客户端，由客户端的浏览器负责解压缩并浏览。相对于普通的浏览过程HTML ,CSS,Javascript , Text ，它可以节省40%左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，压缩效率也很高。 二、Tomcat配置编辑tomcat目录下的conf/server.xml 123&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 改为: 1234567&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" URIEncoding=\"UTF-8\" compression=\"on\" noCompressionUserAgents=\"gozilla, traviata\" compressableMimeType=\"text/html,text/javascript,text/css\" /&gt; 参数说明: 12345compression=\"on\" 打开压缩功能。compressionMinSize=\"2048\" 启用压缩的输出内容大小，这里面默认为2KB。noCompressionUserAgents=\"gozilla, traviata\" 对于这些浏览器，不启用压缩。compressableMimeType=\"text/html,text/xml\" 压缩类型。URIEncoding=\"UTF-8\" 设置编码为UTF-8。 三、测试对同一个接口，开启gzip压缩和不开启gzip压缩进行测试，不开启gzip，接收数据1.5MB，而开启gzip压缩后接收数据86.4KB，压缩率94% 参考链接: https://blog.csdn.net/qing_gee/article/details/51538598 https://my.oschina.net/refresh/blog/90986","categories":[],"tags":[]}]}